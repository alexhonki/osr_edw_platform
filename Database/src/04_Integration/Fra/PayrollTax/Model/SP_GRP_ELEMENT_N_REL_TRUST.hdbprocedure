PROCEDURE "osr.edw.platform.fra.prt.model::SP_GRP_ELEMENT_N_REL_TRUST"(
	IN  IV_GRP_DATE        DATE,
	OUT ET_ELEMENT         "osr.edw.platform.fra.prt.model::Types.DisjointElementT",
	OUT ET_ELEMENT_REL	   "osr.edw.platform.fra.prt.model::Types.DisjointElementRelT"
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   READS SQL DATA AS
BEGIN

DECLARE LV_GJAHR NVARCHAR(4);
DECLARE LV_GRP_DATE DATE;

DECLARE LV_ORG_PREFIX	NVARCHAR(1); 
DECLARE LV_PSN_PREFIX	NVARCHAR(1);
DECLARE LV_PGP_PREFIX	NVARCHAR(1);

LV_ORG_PREFIX := '0';
LV_PSN_PREFIX := '1';
LV_PGP_PREFIX := '2';


IF :IV_GRP_DATE IS NULL OR :IV_GRP_DATE = TO_DATE('9999-12-31') OR :IV_GRP_DATE = '' THEN 
	SELECT CURRENT_DATE INTO LV_GRP_DATE FROM "osr.hana.platform.synonym::SYS.DUMMY";
ELSE
	LV_GRP_DATE := :IV_GRP_DATE;
END IF;

LT_GROUP = 
SELECT  
"GROUP_TYPE", 
"GROUP_ID", 
"ELEMENT_ID"  -- replaces ORG_ID
FROM "osr.apps.acs.synonym::SAPACS.PRTGRPI2" -- new table for TRUST grouping 
WHERE "GRP_DATE" = :LV_GRP_DATE
;

-- Groups with Common beneficiaries
-- Trusts with multiple beneficiaries
LT_GROUP_TO_SUBSUME = 
SELECT "GROUP_TYPE", "GROUP_ID" FROM :LT_GROUP
GROUP BY "GROUP_TYPE", "GROUP_ID"
HAVING COUNT(*) > 1
;

-- Get all the beneficiaries for those groups identified
lt_2bsubsume = 
SELECT 
"GRP_MEM"."GROUP_TYPE" AS "GROUP_TYPE",
"GRP_MEM"."ELEMENT_ID" AS "ELEMENT_ID",
"GRP_MEM"."GROUP_ID" AS "GROUP_ID"
FROM 
:LT_GROUP AS "GRP_MEM"
INNER JOIN 
:LT_GROUP_TO_SUBSUME AS "GRP"
ON  "GRP_MEM"."GROUP_TYPE" = "GRP"."GROUP_TYPE"
AND "GRP_MEM"."GROUP_ID" = "GRP"."GROUP_ID"
;

-- Join the list with itself
-- get a matrix of relationships 
lt_disjoint_element_rel = 
-- members in the same initial group should have relation, build self connection
SELECT DISTINCT "L"."ELEMENT_ID" AS "ELEMENT_ID_L", "R"."ELEMENT_ID" AS "ELEMENT_ID_R"
FROM 
:lt_2bsubsume AS "L" 
INNER JOIN 
:lt_2bsubsume AS "R"
ON  "L"."GROUP_ID" = "R"."GROUP_ID"
AND "L"."GROUP_TYPE" = "R"."GROUP_TYPE"
;

lt_disjoint_element_rel = 
-- members in the same initial group should have relation, build self connection
SELECT DISTINCT "L"."ELEMENT_ID" AS "ELEMENT_ID_L", "R"."ELEMENT_ID" AS "ELEMENT_ID_R"
FROM 
:LT_GROUP AS "L" 
INNER JOIN 
:LT_GROUP AS "R"
ON  "L"."GROUP_ID" = "R"."GROUP_ID"
AND "L"."GROUP_TYPE" = "R"."GROUP_TYPE"
;

lt_test = 
				SELECT DISTINCT 
				"ELEMENT_ID_L", 
				"ELEMENT_ID_R", 
				CASE WHEN LEFT("ELEMENT_ID_L", 1) = 'T' THEN LTRIM("ELEMENT_ID_L", 'T') ELSE LTRIM("ELEMENT_ID_L", 'C')  END AS "ELEMENT_L_NUM",
				CASE WHEN LEFT("ELEMENT_ID_R", 1) = 'T' THEN LTRIM("ELEMENT_ID_R", 'T') ELSE LTRIM("ELEMENT_ID_R", 'C') END AS "ELEMENT_R_NUM"
			--	CASE when LEFT("ELEMENT_ID_L", 1) = 'T' THEN TO_BIGINT(:LV_ORG_PREFIX ||LTRIM("ELEMENT_ID_L", 'T')) 
			--		ELSE TO_BIGINT(:LV_ORG_PREFIX ||LTRIM("ELEMENT_ID_L", 'C'))  END AS "ELEMENT_L_NUM",
			--		
			--	CASE when LEFT("ELEMENT_ID_R", 1) = 'C' THEN TO_BIGINT(:LV_ORG_PREFIX ||LTRIM("ELEMENT_ID_R", 'C')) 
			--		ELSE TO_BIGINT(:LV_ORG_PREFIX ||LTRIM("ELEMENT_ID_R", 'C'))  END AS "ELEMENT_R_NUM"
--				TO_BIGINT(:LV_ORG_PREFIX || RIGHT("ELEMENT_ID_L",11)) AS "ELEMENT_L_NUM",
--				TO_BIGINT(:LV_ORG_PREFIX || RIGHT("ELEMENT_ID_R",11)) AS "ELEMENT_R_NUM"
				FROM :lt_disjoint_element_rel 
				WHERE "ELEMENT_ID_L" <> "ELEMENT_ID_R"
;
/*
LT_TEST2 = 
		SELECT 
		"ELEMENT_L_NUM", 
		"ELEMENT_R_NUM", 
		CASE WHEN "ELEMENT_L_NUM" < "ELEMENT_R_NUM" THEN CONCAT("ELEMENT_L_NUM","ELEMENT_R_NUM") 
		     WHEN "ELEMENT_L_NUM" > "ELEMENT_R_NUM" THEN CONCAT("ELEMENT_R_NUM","ELEMENT_L_NUM") 
		     ELSE 'SELF_ORG_REL' END AS "REL_KEY"
		FROM :lt_test
;

LT_TEST3 = 
	SELECT 
	"REL_KEY", 
	"ELEMENT_L_NUM", 
	"ELEMENT_R_NUM", 
	ROW_NUMBER( ) OVER (PARTITION BY "REL_KEY" ORDER BY "ELEMENT_L_NUM") AS "ROW_NUM_PARTITION"
	FROM :LT_TEST2;
*/


et_element_rel_temp = 
SELECT "ELEMENT_L_NUM", "ELEMENT_R_NUM","ELEMENT_ID_L", "ELEMENT_ID_R"
FROM
	(
	SELECT "REL_KEY", "ELEMENT_L_NUM", "ELEMENT_R_NUM", ROW_NUMBER( ) OVER (PARTITION BY "REL_KEY" ORDER BY "ELEMENT_L_NUM") AS "ROW_NUM_PARTITION", "ELEMENT_ID_L", "ELEMENT_ID_R"
	FROM 
		(
		SELECT 
		"ELEMENT_L_NUM", 
		"ELEMENT_R_NUM", 
		"ELEMENT_ID_L", 
		"ELEMENT_ID_R", 
		CASE WHEN "ELEMENT_L_NUM" < "ELEMENT_R_NUM" THEN CONCAT("ELEMENT_L_NUM","ELEMENT_R_NUM") 
		     WHEN "ELEMENT_L_NUM" > "ELEMENT_R_NUM" THEN CONCAT("ELEMENT_R_NUM","ELEMENT_L_NUM") 
		     ELSE 'SELF_ORG_REL' END AS "REL_KEY"
		FROM 
			(
				SELECT DISTINCT 
				"ELEMENT_ID_L", 
				"ELEMENT_ID_R", 
				CASE WHEN LEFT("ELEMENT_ID_L", 1) = 'T' THEN LTRIM("ELEMENT_ID_L", 'T') ELSE LTRIM("ELEMENT_ID_L", 'C')  END AS "ELEMENT_L_NUM",
				CASE WHEN LEFT("ELEMENT_ID_R", 1) = 'T' THEN LTRIM("ELEMENT_ID_R", 'T') ELSE LTRIM("ELEMENT_ID_R", 'C') END AS "ELEMENT_R_NUM"
				FROM :lt_disjoint_element_rel 
				WHERE "ELEMENT_ID_L" <> "ELEMENT_ID_R"
			)
		)
	)
WHERE "REL_KEY" <> 'SELF_ORG_REL'
  AND "ROW_NUM_PARTITION" = 1
;

et_element_rel  = 
SELECT "ELEMENT_L_NUM", "ELEMENT_R_NUM"
FROM :et_element_rel_temp;

   ET_ELEMENT = 
   SELECT 
   DISTINCT "ELEMENT_NUM", "ELEMENT" 
   FROM (
   SELECT 
   "ELEMENT_L_NUM" AS "ELEMENT_NUM",  
   "ELEMENT_ID_L" AS "ELEMENT" FROM :et_element_rel_temp
   UNION
   SELECT 
   "ELEMENT_R_NUM" AS "ELEMENT_NUM", 
   "ELEMENT_ID_R" AS "ELEMENT" FROM :et_element_rel_temp
   )
   ;
   /*
       table type DisjointElementT_TR {
        ELEMENT_NUM : Integer64;
        ELEMENT     : Integer64;
    };
    table type DisjointElementRelT {
        ELEMENT_L_NUM : Integer64;
        ELEMENT_R_NUM : Integer64;
    };
    */

END